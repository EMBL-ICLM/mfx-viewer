function [valid, data] = validate_raw_data (app, folder, file_name)

    valid = false;
    data = [];
    
    % try load the data with provided path, store file related properties
    fullpath = fullfile(folder, file_name);
    

    if ~exist(fullpath, 'file') % file does not exist.
        warning("MINFLUX data loading error: empty data!");
      warningMessage = sprintf('Warning: file does not exist:\n%s', fullFileName);
      uiwait(msgbox(warningMessage));
    end


    raw_data = load( fullpath );
    if isempty(raw_data)
        warning("MINFLUX data loading error: empty data!");
        return;
    end

    % parse and store file related properties
    file = struct;
    file.name = file_name;
    file.folder = folder;
    dt_sys = System.IO.File.GetCreationTime(fullpath);  % get the file creation date and time into string, e,g: format: "2025-Feb-10, 14:35:15"
    dt_mat = datetime(dt_sys.Year, dt_sys.Month, dt_sys.Day, dt_sys.Hour, dt_sys.Minute, dt_sys.Second);
    dt_mat.Format = "yyyy-MMM-dd, HH:mm:ss";
    file.datetime = string(dt_mat);
    

    
    % check in preference setup, how to load data
    load_all_iteration = strcmp(app.Prefs.data.iter_load, "all");
    load_effective_cfr = app.Prefs.data.load_efc_cfr;
    %load_all_dcr = app.Prefs.data.load_all_dcr;


    % parse, sort and store MINFLUX data attributes and property, udpate
    % raw data to account for early Abberrior format that value wrapped in itr
    property = struct;
    [file.raw_data, attributes, property.num_loc, property.num_itr] = arrange_MINFLUX_data_structure (raw_data, load_all_iteration, load_effective_cfr);
    if isempty(attributes)
        return;
    end
    % compute calibration related parameters, moved to function "compute_extra_property.m"


    % combine file, property, and attributes to data structure
    data = struct("file", file, "prop", property, "attr", attributes);
    valid = true;

end

    %calibration = struct; %?

                % % remove reference point attribute
                % if isfield(file.raw_data, 'mbm')
                %     attributes = rmfield(attributes, 'mbm');
                % end
                % 
                % % Abberrior Imspector format, unwrap attr contained in
                % % 'itr'
                % if ~isfield(file.raw_data, 'loc')
                %     names_1 = fieldnames(attributes.itr);
                %     cells_1 = struct2cell(attributes.itr);
                %     attributes = rmfield(attributes, 'itr');
                %     names_2 = fieldnames(attributes);
                %     cells_2 = struct2cell(attributes);
                %     attributes = cell2struct([cells_1; cells_2], [names_1; names_2]);
                %     file.raw_data = attributes;
                % end
                % 
                % % check if localization data exist (It should be always
                % % true)
                % if ~isfield(attributes, 'loc')
                %     errordlg('Cannot find localization data!', 'Wrong format!');
                %     %warning("MINFLUX data format wrong, cannot find
                %     %localization data!");
                %     return
                % end
                % 
                % % get complete data attribute name list, store it in
                % % property
                % property.attr_names = fieldnames(attributes);
                % 
                % % get N(loc) and N(itr)
                % itr = attributes.itr;
                % [property.num_loc, property.num_itr] = size(itr);
                % vld = true(property.num_loc, 1);
                % if isfield(attributes, 'vld')
                %     vld = attributes.vld;
                % end
                % % arrange format and dimension of nLoc and nItr
                % if property.num_loc == 1
                %     property.num_loc = property.num_itr;    % swap to get the correct number of localizations
                %     itr = itr';
                %     if property.num_loc == 1    % data with only 1 localization, invalid
                %         errordlg('Data has only 1 localization data point, abort import!', 'Wrong format!');
                %         %warning("MINFLUX data appear to have only 1
                %         %localization data point, abort import!")
                %         return
                %     end
                %     property.num_itr = 1;       % only 1 iteration
                %     warning("MINFLUX data appear to have only 1 iteration!");
                % end
                % property.num_loc = size(attributes.loc(vld, :), 1); % only load valid data into app.data
                % 
                % % arrange attribute values to be: num_loc by 1 (num_loc
                % % row, 1 column) check pref if load all iteration, added
                % % iter sub field to data: iter: 1, 2, 3, ..., num_itr, all
                % % check effective cfr, efc, dcr iteration and so on
                % 
                % for i = 1 : length(property.attr_names)
                % 
                %     % check attr dimension
                %     attrName = property.attr_names{i};
                %     value = attributes.(attrName);
                % 
                %     % squeeze localization related attribute that has 3
                %     % dimension, always take last iteration value
                %     % regardless preference setup
                %     if ndims(value) == 3   % loc, lnc, ext
                %         attributes = rmfield(attributes, attrName);
                %         value = squeeze(value(vld, end, :));   % only take last iteration for 3D data
                %         attributes.([attrName, '_x']) = value(:, 1);
                %         attributes.([attrName, '_y']) = value(:, 2);
                %         attributes.([attrName, '_z']) = value(:, 3);
                %         continue;
                %     end
                % 
                %     % swap value to N by 1
                %     if (size(value, 1) == 1)
                %         value = value';
                %     end
                % 
                %     % check which iteration 'cfr' and 'efc' might has valid
                %     % values
                %     if strcmp(attrName, 'cfr') || strcmp(attrName, 'efc')
                %         [~, idx] = max( sum( abs(value), "omitnan" ) ); % take value from iteration that store the max sum of values
                %         %if idx ~= property.num_itr
                %             fprintf('reading %s from iteration %d (%d / %d).\n', ...
                %                 attrName, 1 + itr(1, idx), idx, property.num_itr);
                %         %end
                %         value = value(vld, idx);
                %     else
                %         value = value(vld, end);
                %     end
                % 
                %     % store re-arranged value back to attribute
                %    attributes.(attrName) = value;
                % end
    


